#!/usr/bin/env python
# vim: set filetype=python sw=2 sts=2 et nofoldenable :
# This is a python script.
# If you encounter problemes when executing it on its own, start it with a python interpreter
import sys
import subprocess
import os
import shutil
import copy

sys.dont_write_bytecode = True
from build_system.detect_cpu import detect_cpu
from build_system.configure_gcc import configure_gcc
from build_system.configure_icc import configure_icc
from build_system.configure_clang import configure_clang
from build_system.configure_msc import configure_msc
from build_system.feast_util import remove_string
from build_system.feast_util import remove_substring
from build_system.feast_util import is_found
from build_system.feast_util import find_exe
from build_system.feast_util import get_output
from build_system.thirdparty_package import *

#TODO help, ? und guess nicht in sys.argv[0] suchen
#TODO scalasca
#TODO cpu=string um cpu direkt anzugeben

# output help screen
if len(sys.argv) > 1 and ("help" in " ".join(sys.argv) or "?" in " ".join(sys.argv)):
  print ("Usage: configure_feast [build_id]/[guess]/[help]")
  print ("")
  print ("Configure FEAST and set up all necessary environment variables.")
  print ("You can execute the script (located in the source directory)  from any folder,")
  print ("that shall contain your object files and executables, and thus becoming your build directory.")
  print ("")
  print ("Please note that you need to rerun this configure script after you have altered the")
  print ("software or hardware stack of your computer.")
  print ("")
  print ("============= REQUIREMENTS ==================")
  print ("Needs cmake (at least version 2.8) to run properly.")
  print ("")
  print ("============= EXAMPLES ==================")
  print ("")
  print ("Let configure_feast choose suitable configuration")
  print ("by inspecting available tools in your $PATH:")
  print ("    %s"%sys.argv[0])
  print ("or")
  print ("    %s guess"%sys.argv[0])
  print
  print ("Use a specific build id:")
  print ("    %s build-id"%sys.argv[0])
  print ("Example:")
  print ("    %s gcc-mpi-opt"%sys.argv[0])
  print ("")
  print ("============== BUILD ID ====================")
  print ("The FEAST build-id is a string of various keywords, delimited by hyphes or whitespaces")
  print ("It is used to choose different tools and configurations related to the build process.")
  print ("With the exception of the additional backends, you can choose one token out of each category.")
  print ("These categories are:")
  print ("  Build Mode: debug, opt")
  print ("  Parallelisation: serial, mpi")
  print ("  Compiler: gcc, icc, clang, msc")
  print ("  Compiler frontends: ccache")
  print ("  Backends: cuda, mkl")
  print ("  Generators: unixmake, ninja, xcode, mingw, msys, msc - defaults to unixmake if none is choosen")
  print ("  Instrumentation: scalasca (not implemented yet)")
  print ("  Debugging: valgrind, cudamemcheck")
  print ("  Precision extensions: quadmath")
  print ("  Third party source code: alglib, umfpack")
  print ("")
  print ("Note that cudamemcheck is only active if cuda is activated, too.")
  print ("Note that you need to provide at least a build mode, a parallelisation mode and a compiler.")
  print ("Note that the actual compiler version and mpi implementation is choosen by first come, fist serve")
  print ("corresponding to your $PATH settings.")
  print ("Note that the source code for third party libraries is automatically downloaded if it is not")
  print ("provided in the first place.")
  print ("The target cpu is detected automatically manual override options are not implemented yet.")
  print ("")
  print ("============== ADDITIONAL OPTIONS ==============")
  print ("--system_host_compiler=/usr/bin/gcc")
  print ("  Selects the system compiler (and header files) used by icc.")
  print ("--cuda_host_compiler=/usr/bin/gcc")
  print ("  Selects the system compiler (and header files) used by nvcc.")
  print ("--cuda_arch=sm_20")
  print ("  Selects the cuda architecture target (defaults to sm_20 if not set).")
  print ("--export_compile_commands")
  print ("  Let CMake export the used compile commands to compile_commands.json.")
  print ("--cpu=cputype")
  print ("  Override cpu auto detection with provided string (see build_system/detect_cpu.py for a list).")
  print ("--compiler=path/to/binary")
  print ("  Override default c++ compiler binary by absolute path to binary.")
  print ("")
  print ("Note that the first gcc(g++) in $PATH is choosen as the cuda host compiler, if no other one is provided.")
  sys.exit()

#get path to feast source trunk
trunk_dirname = os.path.abspath(os.path.dirname(sys.argv[0]))

#clear all related
os.environ["CXXFLAGS"] = ""
os.environ["CXX"] = ""
os.environ["CC"] = ""
os.environ["OMP_CXX"] = ""
os.environ["OMP_CC"] = ""
os.environ["MPICH_CXX"] = ""
os.environ["MPICH_CC"] = ""

extra_options = []
#separate extra options from build id
for i in range(1, len(sys.argv)):
  if len(sys.argv[i]) > 2 and sys.argv[i][:2] == "--":
    extra_options.append(sys.argv[i])

# guess a fitting configuration and search for available compilers
if len(sys.argv) == 1 or "guess" in sys.argv:
  buildid_string = "opt"
  if is_found("mpic++") or is_found("mpicxx"):
    buildid_string += "-mpi"
  else:
    buildid_string += "-serial"
  if is_found("g++"):
    buildid_string += "-gcc"
  elif is_found("icpc"):
    buildid_string += "-icc"
  elif is_found("clang++"):
    buildid_string += "-clang"

  if is_found("nvcc"):
    buildid_string += "-cuda"
#TODO suchen nach mkl

# use provided build id
else:
  #add every parameter to the build id that is no extra_option
  buildid_string = ""
  for i in range(1, len(sys.argv)):
    if not (len(sys.argv[i]) > 2 and sys.argv[i][:2] == "--"):
      buildid_string += sys.argv[i] + "-"

buildid_string = buildid_string.strip("-")
#generate handy build id array of tokens
buildid = buildid_string.split("-")
#list of buildid tokens, remove token when used, results in list of unused tokens
unused_tokens = copy.deepcopy(buildid)

#initialise variables
cxxflags = ""
ldflags = ""
cmake_flags = "-DBUILD_ID:STRING=" + buildid_string

#choose makefile generator. missing entry defaults to unix makefiles
if "ninja" in buildid:
  remove_string(unused_tokens, "ninja")
  generator = "Ninja"
elif "xcode" in buildid:
  remove_string(unused_tokens, "xcode")
  generator = "Xcode"
elif "mingw" in buildid:
  remove_string(unused_token, "mingw")
  generator = "MinGW Makefiles"
elif "msys" in buildid:
  remove_string(unused_token, "msys")
  generator = "MSYS Makefiles"
elif "unixmake" in buildid:
  remove_string(unused_tokens, "unixmake")
  generator = "Unix Makefiles"
elif "msc" in buildid:
  remove_string(unused_tokens, "msc")
  if "x64" in buildid:
    remove_string(unused_tokens, "x64")
    generator = "Visual Studio 12 Win64" # 64-bit compiler
  else:
    generator = "Visual Studio 12" # 32-bit compiler
  # Override the compiler version
  cmake_flags += " -T \"CTP_Nov2013\""
else:
  generator = "Unix Makefiles"

# optimisation/debug mode aka build mode selection
if "debug" in buildid or "noop" in buildid:
  remove_string(unused_tokens, "debug")
  remove_string(unused_tokens, "noop")
  cmake_flags += " -DFEAST_DEBUG_MODE:BOOL=ON"
elif "opt" in buildid or "release" in buildid:
  remove_string(unused_tokens, "opt")
  remove_string(unused_tokens, "release")
  cmake_flags += " -DFEAST_DEBUG_MODE:BOOL=OFF"
else:
  print ("Error: No supported build mode (opt/debug) found in build id:")
  print (buildid_string)
  sys.exit(1)
if "quadmath" in buildid:
  remove_string(unused_tokens, "quadmath")
  cmake_flags += " -DFEAST_HAVE_QUADMATH:BOOL=ON"
  ldflags += " -lquadmath"

# parallelisation selection
if "serial" in buildid:
  cmake_flags += " -DFEAST_SERIAL_MODE:BOOL=ON"
  remove_string(unused_tokens, "serial")
elif "mpi" in buildid:
  remove_string(unused_tokens, "mpi")
  cmake_flags += " -DFEAST_SERIAL_MODE:BOOL=OFF"
  cmake_flags += " -DFEAST_MPI:BOOL=TRUE"
else:
  print ("Error: No mpi statement nor serial statement found in build id:")
  print (buildid_string)
  sys.exit(1)

#evaluate extra options
cputype = ""
system_host_compiler = ""
cuda_host_compiler = ""
compiler = ""
cuda_arch = ""
for option in extra_options:
  if option.startswith("--cpu="):
    if cputype:
      print ("Error: multiple cpu parameters in\n" + "\n".join(extra_options))
      exit(1)
    cputype = option.replace("--cpu=", "", 1)

  if option.startswith("--system_host_compiler="):
    if system_host_compiler:
      print ("Error: multiple system_host_compiler parameters in\n" + "\n".join(extra_options))
      exit(1)
    system_host_compiler = option.replace("--system_host_compiler=", "", 1)
    cmake_flags += " -DFEAST_SYSTEM_HOST_COMPILER=" + system_host_compiler

  if option.startswith("--cuda_host_compiler="):
    if cuda_host_compiler:
      print ("Error: multiple cuda_host_compiler parameters in\n" + "\n".join(extra_options))
      exit(1)
    cuda_host_compiler = option.replace("--cuda_host_compiler=", "", 1)

  if option.startswith("--compiler="):
    if compiler:
      print ("Error: multiple compiler parameters in\n" + "\n".join(extra_options))
      exit(1)
    compiler = option.replace("--compiler=", "", 1)

  if option.startswith("--cuda_arch="):
    if cuda_arch:
      print ("Error: multiple cuda_arch parameters in\n" + "\n".join(extra_options))
      exit(1)
    cuda_arch = option.replace("--cuda_arch=", "", 1)

  if option.startswith("--export_compile_commands"):
    cmake_flags += " -DCMAKE_EXPORT_COMPILE_COMMANDS=ON"

if not cputype:
  cputype = detect_cpu()
cmake_flags += " -DFEAST_CPU_TYPE:STRING=" + cputype

#compiler selection
if "gcc" in buildid or "gnu" in buildid or "g++" in buildid:
  if not compiler:
    compiler="g++"
  if not is_found(compiler):
    print ("Error: Chosen compiler binary '" + compiler +"' not found!")
    sys.exit(1)
  remove_string(unused_tokens, "gcc")
  remove_string(unused_tokens, "gnu")
  os.environ["CC"] = "gcc"
  os.environ["CXX"] = compiler
  cxxflags += " " + configure_gcc (cputype, buildid, compiler)
  if "coverage" in buildid:
    remove_string(unused_tokens, "coverage")
    ldflags += " -fprofile-arcs -ftest-coverage"
elif "icc" in buildid or "intel" in buildid or "icpc" in buildid:
  if not compiler:
    compiler = "icpc"
  if not is_found("icpc"):
    print ("Error: Chosen compiler binary '" + compiler +"' not found!")
    sys.exit(1)
  remove_string(unused_tokens, "icc")
  remove_string(unused_tokens, "intel")
  os.environ["CC"] = "icc"
  os.environ["CXX"] = compiler
  cxxflags += " " + configure_icc (cputype, buildid, compiler, system_host_compiler)
elif "clang" in buildid or "llvm" in buildid:
  if not compiler:
    compiler = "clang++"
  if not is_found("clang++"):
    print ("Error: Chosen compiler binary '" + compiler +"' not found!")
    sys.exit(1)
  remove_string(unused_tokens, "clang")
  remove_string(unused_tokens, "llvm")
  os.environ["CC"] = "clang"
  os.environ["CXX"] = compiler
  cxxflags += " " + configure_clang (cputype, buildid, compiler)
elif "msc" in buildid:
  if not is_found("cl"):
    print ("Error: Chosen compiler binary 'cl' not found!")
    sys.exit(1)
  remove_string(unused_tokens, "msc")
  os.environ["CC"] = "cl"
  if compiler:
    os.environ["CXX"] = compiler
  else:
    os.environ["CXX"] = "cl"
  cxxflags += " " + configure_msc (cputype, buildid)
else:
  print ("Error: No supported compiler found in build id:")
  print (buildid_string)
  sys.exit(1)

if "ccache" in buildid:
  if not is_found("ccache"):
    print ("Error: Choosen compiler frontend binary ccache not found!")
    sys.exit(1)
  print("ccache version: " + get_output("ccache -V")[0])
  remove_string(unused_tokens, "ccache")
  os.environ["CC"] = "ccache " + os.environ["CC"]
  os.environ["CXX"] = "ccache " + os.environ["CXX"]
  cmake_flags += " -DFEAST_USE_COMPILER_WRAPPER:BOOL=ON"

#additional backends
if "cuda" in buildid:
  if not is_found("nvcc"):
    print ("Error: Choosen backend compiler binary nvcc not found!")
    sys.exit(1)
  remove_string(unused_tokens, "cuda")
  cmake_flags += " -DFEAST_BACKENDS_CUDA:BOOL=ON"
  if not cuda_arch:
    cuda_arch = "sm_20"
  cmake_flags += " -DFEAST_CUDA_ARCH=" + cuda_arch

  if "cudamemcheck" in buildid:
    remove_string(unused_tokens, "cudamemcheck")
    cmake_flags += " -DFEAST_CUDAMEMCHECK:BOOL=ON"

  if not cuda_host_compiler:
    cuda_host_compiler = find_exe("g++")
  cmake_flags += " -DFEAST_CUDA_HOST_COMPILER=" + cuda_host_compiler

if "mkl" in buildid:
  remove_string(unused_tokens, "mkl")
  cmake_flags += " -DFEAST_BACKENDS_MKL:BOOL=ON"
  cxxflags += " -DMKL_ILP64"

if "valgrind" in buildid:
  if not is_found("valgrind"):
    print ("Error: Choosen debugger valgrind not found!")
    sys.exit(1)
  print("valgrind version: " + get_output("valgrind --version")[0])
  remove_string(unused_tokens, "valgrind")
  cmake_flags += " -DFEAST_VALGRIND:BOOL=ON"

# optional third party libraries
for package in available_packages(trunk_dirname+os.sep+"build_system",trunk_dirname+os.sep+"thirdparty"):
  if package.name in buildid:
    package.add()
    cmake_flags += package.cmake_flags
    remove_string(unused_tokens, package.name)

# clean up previous configurations
clean = [ "CMakeCache.txt", trunk_dirname+os.sep+"CMakeCache.txt" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "feast_config.hpp", trunk_dirname+os.sep+"feast_config.hpp" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "rules.ninja", trunk_dirname+os.sep+"rules.ninja" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "build.ninja", trunk_dirname+os.sep+"build.ninja" ]
for i in clean:
  if os.path.exists(i):
    os.unlink(i)
clean = [ "CMakeFiles", trunk_dirname+os.sep+"CMakeFiles" ]
for i in clean:
  if os.path.exists(i):
    shutil.rmtree(i)

#export compiler/linker flags
os.environ["CXXFLAGS"] = cxxflags
os.environ["LDFLAGS"] = ldflags

print("cmake version: " + get_output("cmake --version")[0])

#print out choosen configuration
print ("============== configure_feast ===========")
print ("Build-ID: " + buildid_string)
if len(unused_tokens) == 0:
  #print ("Unused Build-ID tokens: none")
  pass
else:
  print
  print ("Warning: Unused Build-ID tokens: " + "-".join(unused_tokens))
print
print ("Extra Options: " + " ".join(extra_options))
print
print ("CPU Type: " + cputype)
print
print ("cxx: " + os.environ["CXX"])
print
print ("cxxflags: " + os.environ["CXXFLAGS"])
print
print ("ldflags: " + os.environ["LDFLAGS"])
print
print ("Generator: " + generator)
print
print ("cmake  %s -G\"%s\" \"%s\"" % (cmake_flags, generator, trunk_dirname))
print
#start actual configuration
print ("============== CMAKE =====================")
sys.stdout.flush()
sys.stderr.flush()
subprocess.call("cmake  %s -G\"%s\" \"%s\"" % (cmake_flags, generator, trunk_dirname), shell=True)
