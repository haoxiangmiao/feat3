#pragma once
#ifndef KERNEL_GEOMETRY_EXPORT_VTK_HPP
#define KERNEL_GEOMETRY_EXPORT_VTK_HPP 1

// includes, FEAST
#include <kernel/shape.hpp>

// includes, STL
#include <fstream>

namespace FEAST
{
  namespace Geometry
  {
    /// \cond internal
    namespace Intern
    {
      template<typename Shape_>
      struct VTKHelper;

      template<>
      struct VTKHelper< Shape::Simplex<1> >
      {
        enum
        {
          type = 3 // VTK_LINE
        };
        static inline int map(int i)
        {
          return i;
        }
      };

      template<>
      struct VTKHelper< Shape::Simplex<2> >
      {
        enum
        {
          type = 5 // VTK_TRIANGLE
        };
        static inline int map(int i)
        {
          return i;
        }
      };

      template<>
      struct VTKHelper< Shape::Simplex<3> >
      {
        enum
        {
          type = 10 // VTK_TETRA
        };
        static inline int map(int i)
        {
          return i;
        }
      };

      template<>
      struct VTKHelper< Shape::Hypercube<1> >
      {
        enum
        {
          type = 3 // VTK_LINE
        };
        static inline int map(int i)
        {
          return i;
        }
      };

      template<>
      struct VTKHelper< Shape::Hypercube<2> >
      {
        enum
        {
          type = 9 // VTK_QUAD
        };
        static inline int map(int i)
        {
          static int v[] = {0, 1, 3, 2};
          return v[i];
        }
      };

      template<>
      struct VTKHelper< Shape::Hypercube<3> >
      {
        enum
        {
          type = 12 // VTK_HEXAHEDRON
        };
        static inline int map(int i)
        {
          static int v[] = {0, 1, 3, 2, 4, 5, 7, 6};
          return v[i];
        }
      };
    } // namespace Intern
    /// \endcond

    /**
     * \brief Provisional VTK exporter class template
     *
     * This class template is a provisional VTK exporter which will be replaced by a more mature one later.
     * \author Peter Zajac
     */
    template<typename Mesh_>
    class ExportVTK
    {
    public:
      /// mesh type
      typedef Mesh_ MeshType;
      /// vertex set type
      typedef typename MeshType::VertexSetType VertexSetType;

    protected:
      /// reference to mesh to be exported
      const MeshType& _mesh;
      /// output stream
      std::ofstream _ofs;
      /// number of vertices in mesh
      Index _num_verts;
      /// number of cells in mesh
      Index _num_cells;

    public:
      explicit ExportVTK(const MeshType& mesh) :
        _mesh(mesh),
        _num_verts(mesh.get_num_entities(0)),
        _num_cells(mesh.get_num_entities(MeshType::shape_dim))
      {
        CONTEXT("ExportVTK::ExportVTK()");
      }

      virtual ~ExportVTK()
      {
        CONTEXT("ExportVTK::~ExportVTK()");
      }

      bool open(const String& filename)
      {
        CONTEXT("ExportVTK::begin()");
        using std::endl;

        // try to open a file
        _ofs.open(filename.c_str());
        if(!(_ofs.is_open() && _ofs.good()))
          return false;

        // write VTK header
        _ofs << "# vtk DataFile Version 2.0" << endl;
        _ofs << "Generated by FEAST v" << version_major << "." << version_minor << "." << version_patch << endl;
        _ofs << "ASCII" << endl;
        _ofs << "DATASET UNSTRUCTURED_GRID" << endl;

        // write vertex coordinates
        const typename MeshType::VertexSetType& vtx = _mesh.get_vertex_set();
        Index num_verts = vtx.get_num_vertices();
        int num_coords = vtx.get_num_coords();
        ASSERT_((num_coords >= 1) && (num_coords <= 3));
        _ofs << "POINTS " << num_verts << " double" << endl;
        for(Index i(0); i < num_verts; ++i)
        {
          _ofs << vtx[i][0];
          for(int j(1); j < num_coords; ++j)
          {
            _ofs << " " << vtx[i][j];
          }
          for(int j(num_coords); j < 3; ++j)
          {
            _ofs << " 0.0";
          }
          _ofs << std::endl;
        }

        typedef Intern::VTKHelper<typename MeshType::ShapeType> VTKHelperType;

        // fetch index set
        const typename MeshType::template IndexSet<MeshType::shape_dim,0>::Type& idx =
          _mesh.template get_index_set<MeshType::shape_dim, 0>();
        Index num_cells = _mesh.get_num_entities(MeshType::shape_dim);
        int num_idx = idx.get_num_indices();

        // write cells
        _ofs << "CELLS " << num_cells << " " << ((num_idx+1)*num_cells) << endl;
        for(Index i(0); i < num_cells; ++i)
        {
          _ofs << num_idx;
          for(int j(0); j < num_idx; ++j)
          {
            _ofs << " " << idx[i][VTKHelperType::map(j)];
          }
          _ofs << endl;
        }

        // write cell types
        _ofs << "CELL_TYPES " << num_cells << endl;
        for(Index i(0); i < num_cells; ++i)
        {
          _ofs << VTKHelperType::type << endl;
        }

        // okay
        return true;
      }

      template<typename T_>
      void write_vertex_scalar(const String& name, const T_* data)
      {
        _ofs << "POINT_DATA " << _num_verts << std::endl;
        _ofs << "SCALARS " << name << " double 1" << std::endl;
        _ofs << "LOOKUP_TABLE default" << std::endl;
        for(Index i(0); i < _num_verts; ++i)
        {
          _ofs << " " << data[i] << std::endl;
        }
      }

      template<typename T_>
      void write_cell_scalar(const String& name, const T_* data)
      {
        _ofs << "CELL_DATA " << _num_cells << std::endl;
        _ofs << "SCALARS " << name << " double 1" << std::endl;
        _ofs << "LOOKUP_TABLE default" << std::endl;
        for(Index i(0); i < _num_cells; ++i)
        {
          _ofs << " " << data[i] << std::endl;
        }
      }

      void close()
      {
        _ofs.close();
      }
    }; // class ExportVTK
  } // namespace Geometry
} // namespace FEAST

#endif // KERNEL_GEOMETRY_EXPORT_VTK_HPP
