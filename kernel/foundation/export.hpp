#pragma once
#ifndef KERNEL_FOUNDATION_EXPORT_HPP
#define KERNEL_FOUNDATION_EXPORT_HPP 1

#include <kernel/foundation/base.hpp>
#include <kernel/foundation/mesh.hpp>
#include <kernel/foundation/halo.hpp>
#include <iostream>
#include <cmath>

namespace FEAST
{
  namespace Foundation
  {
    template<typename FT_, typename MT_, typename AST_>
    class MeshExporter
    {
    };

    class VTK
    {
    };

    /**
     * \brief VTK file exporter for mesh types
     *
     * \author Markus Geveler
     */
    template<typename MT_, typename AST_>
    class MeshExporter<VTK, MT_, AST_>
    {
      public:
        MeshExporter(const MT_& m, const AST_& a) :
          _mesh(m),
          _coords(a)
        {
        }

        void write(const std::string filename)
        {
          std::ofstream ofs(filename.c_str());
          if((ofs.is_open() && ofs.good()))
          {
            ofs << "# vtk DataFile Version 2.0" << std::endl;
            ofs << "Generated by FEAST v" << version_major << "." << version_minor << "." << version_patch << std::endl;
            ofs << "ASCII" << std::endl;
            ofs << "DATASET POLYDATA" << std::endl;
            ofs << "POINTS " << _coords.at(0).size() << " double" << std::endl;

            for(Index i(0) ; i < _coords.at(0).size() ; ++i)
            {
              for(Index j(0) ; j < _coords.size() ; ++j)
              {
                if(j > 0)
                  ofs << " ";

                ofs << _coords.at(j).at(i);
              }
              for(Index j(0) ; j < Index(Index(3) - _coords.size()) ; ++j)
              {
                ofs << " 0";
              }

              ofs << std::endl;
            }

            ofs << "VERTICES " << _mesh.num_polytopes(pl_vertex) << " " << 2 * _mesh.num_polytopes(pl_vertex) << std::endl;
            for(Index i(0) ; i < _mesh.num_polytopes(pl_vertex) ; ++i)
              ofs << "1" << " " << i << std::endl;

            ofs << "LINES " << _mesh.num_polytopes(pl_edge) << " " << 3 * _mesh.num_polytopes(pl_edge) << std::endl;
            for(Index i(0) ; i < _mesh.num_polytopes(pl_edge) ; ++i)
            {
              typename MT_::topology_type_::storage_type_ verts(_mesh.get_adjacent_polytopes(pl_edge, pl_vertex, i));
              ofs << "2 " << verts.at(0) << " " << verts.at(1) << std::endl;
            }

            ofs << "POLYGONS " << _mesh.num_polytopes(pl_face) << " " << 5 * _mesh.num_polytopes(pl_face) << std::endl;
            for(Index i(0) ; i < _mesh.num_polytopes(pl_face) ; ++i)
            {
              typename MT_::topology_type_::storage_type_ verts(_mesh.get_adjacent_polytopes(pl_face, pl_vertex, i));

              ///generate map
              typename MT_::topology_type_::storage_type_ map;
              // 0
              map.push_back(0);
              //odd indices in increasing order
              for(Index j(1) ; j < verts.size() ; ++j)
              {
                if(j % 2 == 1)
                  map.push_back(j);
              }
              //even indices in decreasing order
              for(Index j(verts.size() - 1) ; j >= 1 ; --j)
              {
                if(j % 2 == 0)
                  map.push_back(j);
              }

              ofs << "4";
              for(Index j(0) ; j < verts.size() ; ++j)
                 ofs  << " " << verts.at(map.at(j));
              ofs << std::endl;
            }

            ofs.close();
          }

        }

      private:
        const MT_& _mesh;
        const AST_& _coords;
    };
  }
}
#endif
