#!/usr/bin/env python
# vim: set filetype=python sw=2 sts=2 et nofoldenable :
# This is a python script.
# If you encounter problemes when executing it on its own, start it with a python interpreter
from __future__ import print_function
import sys
import os
import subprocess
import socket
import shutil
import time
import datetime
import peewee as pw
from cmake_modules.feast_util import is_found
from cmake_modules.feast_util import get_output
from cmake_modules.feast_util import get_output_utf8

sys.dont_write_bytecode = True



src_dirname = os.path.abspath(os.path.dirname(sys.argv[0]))
myDB = pw.MySQLDatabase("feastdash", host="augias", port=3306, user="feastdash", passwd="feastdash")
myDB.connect()

class MySQLModel(pw.Model):
  """A base model that will use our MySQL database"""
  class Meta:
    database = myDB

class User(MySQLModel):
  username = pw.CharField()

class BranchQueue(MySQLModel):
  branch = pw.CharField()

class Run(MySQLModel):
  branch = pw.CharField()
  hostname = pw.CharField()
  build = pw.CharField()
  starttime = pw.IntegerField()
  endtime = pw.IntegerField()
  notes = pw.TextField()

class Message(MySQLModel):
  runid = pw.ForeignKeyField(Run, related_name="messages", db_column="runid")
  stage = pw.CharField()
  status = pw.CharField()
  timestamp = pw.IntegerField()
  title = pw.CharField()
  body = pw.TextField()

class Attachment(MySQLModel):
  messageid = pw.ForeignKeyField(Message, related_name="attachments", db_column="messageid")
  name = pw.CharField()
  mimetype = pw.CharField()
  data = pw.BlobField()

def run_test(build_id, branch, myDB):
  hostname = socket.gethostname()
  os.chdir(src_dirname)
  build_dirname = src_dirname + os.sep + "build"

  #create test run in database
  r = Run.create(branch=branch, hostname=hostname, build=build_id, starttime=time.time(), endtime=time.time()+300)
  r.save()
  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="directories", body=src_dirname + "\n" + build_dirname)
  m.save()

  #prepare build dir
  shutil.rmtree(build_dirname, True)
  os.mkdir(build_dirname)
  os.chdir(build_dirname)

  #git pull
  os.chdir(src_dirname)
  git_output = get_output("git gc")
  #TODO reactivate git checkout
  #git_output += get_output("git checkout --no-track -B test123" + hostname + " origin/" + branch)
  git_output.insert(0, "hier sollte noch mehr kommen")
  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="git output", body="\n".join(git_output))
  m.save()
  os.chdir(build_dirname)

######### CONFIGURE #########
  configure_command = src_dirname + os.sep + "configure-feast " + build_id
  configure_output = get_output(configure_command)
  configure_output = "\n".join(configure_output)
  if "Error" in configure_output:
    m = Message.create(runid=r, stage="configure", status="error", timestamp=time.time(), title="output", body=configure_output)
    m.save()
    return
  elif "Warning" in configure_output:
    m = Message.create(runid=r, stage="configure", status="warning", timestamp=time.time(), title="output", body=configure_output)
    m.save()
  else:
    m = Message.create(runid=r, stage="configure", status="ok", timestamp=time.time(), title="output", body=configure_output)
    m.save()

######### MAKE ###############
  make_output = get_output_utf8("make")
  make_output = get_output_utf8("make tests")
  errors=0
  warnings=0
  for line in make_output:
    if "Error" in line or "error" in line:
      errors+=1
    if "Warning" in line or "warning" in line:
      warnings+=1

  if errors > 0:
    m = Message.create(runid=r, stage="build", status="error", timestamp=time.time(), title="Errors: " + str(errors), body=make_output)
    m.save()
  if warnings > 0:
    m = Message.create(runid=r, stage="build", status="warning", timestamp=time.time(), title="Warnings: " + str(warnings), body=make_output)
    m.save()
  else:
    m = Message.create(runid=r, stage="build", status="ok", timestamp=time.time(), title="Build Log", body=make_output)

######### TEST #####################
  test_output = get_output_utf8("ctest --output-on-failure")

  passed_tests = []
  failed_tests = []
  for idx in xrange(len(test_output)):
    if ".   Passed" in test_output[idx]:
      test_name = test_output[idx].split(": ")
      test_name = test_name[1].split(" .")
      test_name = test_name[0]
      passed_tests.append(test_name)

    elif "***Failed" in test_output[idx]:
      # read out current test name
      test_name = test_output[idx].split(": ")
      test_name = test_name[1].split(" .")
      test_name = test_name[0]
      failed_tests.append(test_name)

      #search for last line corresponding to current failed test
      test_end = idx
      for i in range(idx, len(test_output)):
        if "Start" in test_output[i]:
          test_end = i
          break
      #gather all output lines of current failed test
      part_output = ""
      for i in range(idx, test_end):
        part_output += test_output[i] + "\n"

      m = Message.create(runid=r, stage="test", status="failed", timestamp=time.time(), title=test_name, body=part_output)
      m.save()
      idx = i

  m = Message.create(runid=r, stage="test", status="passed", timestamp=time.time(), title=str(len(passed_tests)) + " tests passed", body=passed_tests)
  m.save()
  m = Message.create(runid=r, stage="test", status="failed", timestamp=time.time(), title=str(len(failed_tests)) + " tests failed", body=failed_tests)
  m.save()
  exit()



################## MAIN ######################

#TODO help, ? und guess nicht in sys.argv[0] suchen
# output help screen
if len(sys.argv) != 1 and ("help" in " ".join(sys.argv) or "?" in " ".join(sys.argv)):
  print ("This python scripts starts regression tests and submits them to a cdash server")
  sys.exit()

if not is_found("cmake"):
  print ("cmake not found! aborting...")
  sys.exit(1)
if not is_found("git"):
  print ("git not found! aborting...")
  sys.exit(1)

# fetch remote branches and create a list of fetched branches
#TODO insert output into database
get_output("git fetch -v -p")
raw_branches = get_output("git branch -a")
raw_branches[:] = [s.strip("* ") for s in raw_branches]

addition = "-unixmake"
if is_found ("nvcc"):
  addition = addition + "-cuda"

#iterate over all branches, that are queued for testing
branches = BranchQueue.select()
for branch in branches:
  #check if branch is present in repository
  branch = branch.branch
  found_branch = False
  for s in raw_branches[:]:
    if "remotes/origin/"+branch in s:
      found_branch = True
      break

  if found_branch == False:
    continue

  if is_found("mpic++"):
    if is_found("g++"):
      run_test("mpi-gcc-debug-coverage-gmp-mkl" + addition, branch, myDB)
      run_test("mpi-gcc-opt-coverage-gmp-mkl" + addition, branch, myDB)
    if is_found("clang++"):
      run_test("mpi-clang-debug-gmp-mkl" + addition, branch, myDB)
      run_test("mpi-clang-opt-gmp-mkl" + addition, branch, myDB)
    if is_found("icpc"):
      run_test("mpi-icc-debug-mkl" + addition, branch, myDB)
      run_test("mpi-icc-opt-mkl" + addition, branch, myDB)

  if is_found("g++"):
    run_test("serial-gcc-debug-coverage-gmp-mkl" + addition, branch, myDB)
    run_test("serial-gcc-opt-coverage-gmp-mkl" + addition, branch, myDB)
  if is_found("clang++"):
    run_test("serial-clang-debug-gmp-mkl" + addition, branch, myDB)
    run_test("serial-clang-opt-gmp-mkl" + addition, branch, myDB)
  if is_found("icpc"):
    run_test("serial-icc-debug-mkl" + addition, branch, myDB)
    run_test("serial-icc-opt-mkl" + addition, branch, myDB)
