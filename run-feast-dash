#!/usr/bin/env python
# vim: set filetype=python sw=2 sts=2 et nofoldenable :
# This is a python script.
# If you encounter problemes when executing it on its own, start it with a python interpreter
from __future__ import print_function
import sys
import os
import subprocess
import socket
import shutil
import time
import datetime
import peewee as pw
from cmake_modules.feast_util import is_found
from cmake_modules.feast_util import get_output
from cmake_modules.feast_util import get_output_utf8

sys.dont_write_bytecode = True



src_dirname = os.path.abspath(os.path.dirname(sys.argv[0]))
myDB = pw.MySQLDatabase("feastdash", host="augias", port=3306, user="feastdash", passwd="feastdash")
myDB.connect()

class MySQLModel(pw.Model):
  """A base model that will use our MySQL database"""
  class Meta:
    database = myDB

class User(MySQLModel):
  username = pw.CharField()

class BranchQueue(MySQLModel):
  branch = pw.CharField()

class Run(MySQLModel):
  branch = pw.CharField()
  hostname = pw.CharField()
  build = pw.CharField()
  starttime = pw.IntegerField()
  endtime = pw.IntegerField()
  notes = pw.TextField()

class Message(MySQLModel):
  runid = pw.ForeignKeyField(Run, related_name="messages", db_column="runid")
  stage = pw.CharField()
  status = pw.CharField()
  timestamp = pw.IntegerField()
  title = pw.CharField()
  body = pw.TextField()

class Attachment(MySQLModel):
  messageid = pw.ForeignKeyField(Message, related_name="attachments", db_column="messageid")
  name = pw.CharField()
  mimetype = pw.CharField()
  data = pw.BlobField()

def run_test(build_id, branch, myDB):
  failed = False
  hostname = socket.gethostname()
  os.chdir(src_dirname)
  build_dirname = src_dirname + os.sep + "build"

  #create test run in database
  r = Run.create(branch=branch, hostname=hostname, build=build_id, starttime=time.time())
  r.save()
  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="directories", body="Source: " + src_dirname + "\n" + "Build: " + build_dirname)
  m.save()

  #prepare build dir
  shutil.rmtree(build_dirname, True)
  os.mkdir(build_dirname)
  os.chdir(build_dirname)

  #git pull
  os.chdir(src_dirname)
  git_output = get_output("git gc --auto")
  git_output += get_output("git checkout --no-track -B test123" + hostname + " origin/" + branch)
  git_output.insert(0, "hier sollte noch mehr kommen")
  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="git output", body="\n".join(git_output))
  m.save()
  os.chdir(build_dirname)

######### CONFIGURE #########
  configure_command = src_dirname + os.sep + "configure-feast " + build_id
  configure_output = get_output(configure_command)
  configure_output = "\n".join(configure_output)
  if "Error" in configure_output:
    m = Message.create(runid=r, stage="configure", status="error", timestamp=time.time(), title="output", body=configure_output)
    m.save()
    r.endtime = time.time()
    r.save()
    return
  elif "Warning" in configure_output:
    m = Message.create(runid=r, stage="configure", status="warning", timestamp=time.time(), title="output", body=configure_output)
    m.save()

  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="configure_output", body=configure_output)
  m.save()

######### MAKE ###############
  def process_compiler_output(token, output):
    failed = False
    last_idx = 0
    part_name = ""
    idx = 0
    while idx < len(make_output):
      #search for building blocks aka all output corresonponding to one build target
      if "Building" in make_output[idx]:
        last_idx = idx
        part_name = make_output[idx].split("/")[-1]
        part_name = part_name.split(".o")[0]
        idx += 1

      # error in building block
      elif token+":" in make_output[idx].lower():
        failed = True
        #search for end of block
        iend = len(make_output)
        for i in range(idx, len(make_output)):
          if "Building" in make_output[i]:
            iend = i
            break
        idx = iend
        #end of block found, dump corresponding lines to message
        part_output = ""
        for j in range(last_idx, idx):
          part_output += make_output[j] + "\n"

        m = Message.create(runid=r, stage="build", status=token, timestamp=time.time(), title=part_name, body=part_output)
        m.save()
        last_idx = idx

      else:
        idx += 1
    return failed

  make_output = get_output_utf8("make -k all tests")
  failed = process_compiler_output("warning", make_output)
  failed |= process_compiler_output("error", make_output)
  if failed == True:
    r.endtime = time.time()
    r.save()
    return

######### TEST #####################
  test_output = get_output_utf8("ctest --output-on-failure --schedule-random")

  idx = 0
  while idx < len(test_output):
    if ".   Passed" in test_output[idx]:
      test_name = test_output[idx].split(": ")
      test_name = test_name[1].split(" .")
      test_name = test_name[0]
      m = Message.create(runid=r, stage="test", status="passed", timestamp=time.time(), title=test_name)
      m.save()
      idx += 1

    elif "***Failed" in test_output[idx]:
      # read out current test name
      test_name = test_output[idx].split(": ")
      test_name = test_name[1].split(" .")
      test_name = test_name[0]

      #search for last line corresponding to current failed test
      test_end = idx
      for i in range(idx, len(test_output)):
        if "Start" in test_output[i]:
          test_end = i
          break
      #gather all output lines of current failed test
      part_output = ""
      for i in range(idx, test_end):
        part_output += test_output[i] + "\n"

      m = Message.create(runid=r, stage="test", status="failed", timestamp=time.time(), title=test_name, body=part_output)
      m.save()
      idx = test_end

    else:
      idx += 1

  r.endtime = time.time()
  r.save()



################## MAIN ######################

#TODO help, ? und guess nicht in sys.argv[0] suchen
# output help screen
if len(sys.argv) != 1 and ("help" in " ".join(sys.argv) or "?" in " ".join(sys.argv)):
  print ("This python scripts starts regression tests and submits them to a cdash server")
  sys.exit()

if not is_found("cmake"):
  print ("cmake not found! aborting...")
  sys.exit(1)
if not is_found("git"):
  print ("git not found! aborting...")
  sys.exit(1)

# fetch remote branches and create a list of fetched branches
#TODO insert output into database
get_output("git fetch -v -p")
raw_branches = get_output("git branch -a")
raw_branches[:] = [s.strip("* ") for s in raw_branches]

addition = "-unixmake"
if is_found ("nvcc"):
  addition = addition + "-cuda"

#iterate over all branches, that are queued for testing
branches = BranchQueue.select()
for branch in branches:
  #check if branch is present in repository
  branch = branch.branch
  found_branch = False
  for s in raw_branches[:]:
    if "remotes/origin/"+branch in s:
      found_branch = True
      break

  if found_branch == False:
    continue

  if is_found("mpic++"):
    if is_found("g++"):
      run_test("mpi-gcc-debug-coverage-gmp-mkl" + addition, branch, myDB)
      run_test("mpi-gcc-opt-coverage-gmp-mkl" + addition, branch, myDB)
    if is_found("clang++"):
      run_test("mpi-clang-debug-gmp-mkl" + addition, branch, myDB)
      run_test("mpi-clang-opt-gmp-mkl" + addition, branch, myDB)
    if is_found("icpc"):
      run_test("mpi-icc-debug-mkl" + addition, branch, myDB)
      run_test("mpi-icc-opt-mkl" + addition, branch, myDB)

  if is_found("g++"):
    run_test("serial-gcc-debug-coverage-gmp-mkl" + addition, branch, myDB)
    run_test("serial-gcc-opt-coverage-gmp-mkl" + addition, branch, myDB)
  if is_found("clang++"):
    run_test("serial-clang-debug-gmp-mkl" + addition, branch, myDB)
    run_test("serial-clang-opt-gmp-mkl" + addition, branch, myDB)
  if is_found("icpc"):
    run_test("serial-icc-debug-mkl" + addition, branch, myDB)
    run_test("serial-icc-opt-mkl" + addition, branch, myDB)
