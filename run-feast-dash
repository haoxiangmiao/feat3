#!/usr/bin/env python
# vim: set filetype=python sw=2 sts=2 et nofoldenable :
# This is a python script.
# If you encounter problemes when executing it on its own, start it with a python interpreter
from __future__ import print_function
import sys
import platform
import os
import re
import subprocess
import socket
import shutil
import time
import datetime
import peewee as pw
from cmake_modules.feast_util import is_found
from cmake_modules.feast_util import get_output
from cmake_modules.feast_util import get_output_utf8

sys.dont_write_bytecode = True

def run_test(build_id, branch, myDB):
  failed = False
  hostname = socket.gethostname()

  if dump_filename != "":
    dump_file = open(dump_filename+"-"+hostname+"-"+branch+"-"+build_id, "w")

  os.chdir(src_dirname)
  build_dirname = src_dirname + os.sep + "build"

  #create test run in database
  r = Run.create(branch=branch, hostname=hostname, build=build_id, starttime=time.time())
  r.save()
  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="directories", body="Source: " + src_dirname + "\n" + "Build: " + build_dirname)
  m.save()

  #prepare build dir
  shutil.rmtree(build_dirname, True)
  os.mkdir(build_dirname)

  #git pull
  git_output = get_output("git gc --auto")
  git_output += get_output("git checkout -f --no-track -B test123" + hostname + " origin/" + branch)
  git_output.append("git HEAD:")
  git_output += get_output("git log HEAD -n1")
  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="git output", body="\n".join(git_output))
  m.save()
  if dump_filename != "":
    dump_file.write("\n" + "\n".join(git_output))
  os.chdir(build_dirname)

#workaround for network base file system to prevent rebuilding everything in ctest phase
  if is_found("sync"):
    get_output("sync")

######### CONFIGURE #########
  configure_command = src_dirname + os.sep + "configure-feast " + build_id
  configure_output = get_output(configure_command)
  configure_output = "\n".join(configure_output)
  if "Error" in configure_output:
    m = Message.create(runid=r, stage="configure", status="error", timestamp=time.time(), title="output", body=configure_output)
    m.save()
    r.endtime = time.time()
    r.save()
    return
  elif "Warning" in configure_output:
    m = Message.create(runid=r, stage="configure", status="warning", timestamp=time.time(), title="output", body=configure_output)
    m.save()

  m = Message.create(runid=r, stage="intern", status="ok", timestamp=time.time(), title="configure_output", body=configure_output)
  m.save()

  if dump_filename != "":
    dump_file.write("\n" + src_dirname + os.sep + "configure-feast " + build_id + "\n")
    dump_file.write("\n" + configure_output)

#workaround for network base file system to prevent rebuilding everything in ctest phase
  if is_found("sync"):
    get_output("sync")

######### MAKE ###############
  def process_compiler_output(pattern, token, output):
    last_idx = 0
    part_name = ""
    idx = 0
    while idx < len(output):
      #search for building blocks aka all output corresonponding to one build target
      if "Building" in output[idx]:
        last_idx = idx
        part_name = output[idx].split("/")[-1]
        part_name = part_name.split(".o")[0]
        idx += 1
      elif "Linking" in output[idx]:
        last_idx = idx
        part_name = output[idx].split(" ")[-1]
        idx += 1

      # error/warning in building block
      elif pattern.search(output[idx].lower()):
        #search for end of block
        iend = len(output)
        for i in range(idx, len(output)):
          if "Building" in output[i] or "Linking" in output[idx]:
            iend = i
            break
        idx = iend
        #end of block found, dump corresponding lines to message
        part_output = ""
        for j in range(last_idx, idx):
          part_output += output[j] + "\n"

        m = Message.create(runid=r, stage="build", status=token, timestamp=time.time(), title=part_name, body=part_output)
        m.save()

      else:
        idx += 1

  if "ninja" in build_id:
    make_command = "ninja -k 999 all tests"
  else:
    make_command = "make -j 4 -O -k all tests"
  make_output = get_output_utf8(make_command)
  process_compiler_output(re.compile("warning:"), "warning", make_output)
  process_compiler_output(re.compile("warning #"), "warning", make_output)
  process_compiler_output(re.compile("error:"), "error", make_output)
  process_compiler_output(re.compile("error #"), "error", make_output)
  process_compiler_output(re.compile("recipe for target '.*' failed"), "error", make_output)
  if dump_filename != "":
    dump_file.write("\n" + make_command + "\n\n")
    dump_file.write("\n".join(make_output))

#workaround for network base file system to prevent rebuilding everything in ctest phase
  if is_found("sync"):
    get_output("sync")

######### TEST #####################
  test_output = get_output_utf8("ctest --output-on-failure --schedule-random")

  idx = 0
  while idx < len(test_output):
    if ".   Passed" in test_output[idx]:
      test_name = test_output[idx].split(": ")
      test_name = test_name[1].split(" .")
      test_name = test_name[0]
      m = Message.create(runid=r, stage="test", status="passed", timestamp=time.time(), title=test_name, body=test_output[idx])
      m.save()
      idx += 1

    elif "***Failed" in test_output[idx]:
      # read out current test name
      test_name = test_output[idx].split(": ")
      test_name = test_name[1].split(" .")
      test_name = test_name[0]

      #search for last line corresponding to current failed test
      test_end = len(test_output)
      for i in range(idx, len(test_output)):
        if "Start" in test_output[i]:
          test_end = i
          break
      #gather all output lines of current failed test
      part_output = ""
      for i in range(idx, test_end):
        part_output += test_output[i] + "\n"

      m = Message.create(runid=r, stage="test", status="failed", timestamp=time.time(), title=test_name, body=part_output)
      m.save()
      idx = test_end

    else:
      idx += 1

  if dump_filename != "":
    dump_file.write("\nctest --output-on-failure --schedule-random\n\n")
    dump_file.write("\n".join(test_output))
    dump_file.close()

  r.endtime = time.time()
  r.save()



################## MAIN ######################

#TODO help, ? und nicht in sys.argv[0] suchen
# output help screen
if len(sys.argv) != 1 and ("help" in " ".join(sys.argv) or "?" in " ".join(sys.argv)):
  print ("This python scripts starts regression tests and submits them to a cdash server")
  print ("Options:")
  print ("dump=absolute_path")
  print ("  dump complete make/ctest output into file given with absolute path, the filename is extended by run specific identifiers.")
  print ("sqlhost=hostname")
  print ("  set hostname as server that runs the sql daemon.")
  print ("sqlport=port")
  print ("  setup port of sql server.")
  sys.exit();

dump_filename = ""
sqlhost = "augias"
sqlport = 3306

for i in range(1, len(sys.argv)):
  if sys.argv[i].startswith("dump="):
    dump_filename = sys.argv[i].replace("dump=", "", 1)
  if sys.argv[i].startswith("sqlhost="):
    sqlhost = sys.argv[i].replace("sqlhost=", "", 1)
  if sys.argv[i].startswith("sqlport="):
    sqlport = int(sys.argv[i].replace("sqlport=", "", 1))

src_dirname = os.path.abspath(os.path.dirname(sys.argv[0]))
myDB = pw.MySQLDatabase("feastdash", host=sqlhost, port=sqlport, user="feastdash", passwd="feastdash", threadlocals=True)
myDB.connect()

class MySQLModel(pw.Model):
  """A base model that will use our MySQL database"""
  class Meta:
    database = myDB

class User(MySQLModel):
  username = pw.CharField()

class BranchQueue(MySQLModel):
  branch = pw.CharField()

class Run(MySQLModel):
  branch = pw.CharField()
  hostname = pw.CharField()
  build = pw.CharField()
  starttime = pw.IntegerField()
  endtime = pw.IntegerField()
  notes = pw.TextField()

class Message(MySQLModel):
  runid = pw.ForeignKeyField(Run, related_name="messages", db_column="runid")
  stage = pw.CharField()
  status = pw.CharField()
  timestamp = pw.IntegerField()
  title = pw.CharField()
  body = pw.TextField()

class Attachment(MySQLModel):
  messageid = pw.ForeignKeyField(Message, related_name="attachments", db_column="messageid")
  name = pw.CharField()
  mimetype = pw.CharField()
  data = pw.BlobField()


if not is_found("cmake"):
  print ("cmake not found! aborting...")
  sys.exit(1)
if not is_found("git"):
  print ("git not found! aborting...")
  sys.exit(1)

src_dirname = os.path.abspath(os.path.dirname(sys.argv[0]))
os.chdir(src_dirname)
# fetch remote branches and create a list of fetched branches
#TODO insert output into database
get_output("git fetch -v -p")
raw_branches = get_output("git branch -a")
raw_branches[:] = [s.strip("* ") for s in raw_branches]

addition = ""
if is_found ("ninja"):
  addition += "-ninja"
else:
  addition += "-unixmake"
if is_found ("nvcc"):
  addition = addition + "-cuda"
if is_found ("ccache"):
  addition = addition + "-ccache"
#unconditionally add umfpack/alglib and delete it before the first test run to trigger package downloads
shutil.rmtree(src_dirname+os.sep+"thirdparty"+os.sep+"alglib", True)
shutil.rmtree(src_dirname+os.sep+"thirdparty"+os.sep+"UMFPACK", True)
shutil.rmtree(src_dirname+os.sep+"thirdparty"+os.sep+"AMD", True)
shutil.rmtree(src_dirname+os.sep+"thirdparty"+os.sep+"SuiteSparse_config", True)
addition = addition + "-alglib"
addition = addition + "-umfpack"

#iterate over all branches, that are queued for testing
branches = BranchQueue.select()
for branch in branches:
  #check if branch is present in repository
  branch = branch.branch
  found_branch = False
  for s in raw_branches[:]:
    if "remotes/origin/"+branch in s:
      found_branch = True
      break

  if found_branch == False:
    continue

  run_test("guess", branch, myDB)

  if platform.system() == "Darwin": # schwarzkopf has no mkl
    run_test("mpi-gcc-debug-coverage" + addition, branch, myDB)
    run_test("mpi-gcc-opt-coverage" + addition, branch, myDB)
    run_test("serial-gcc-debug-coverage" + addition, branch, myDB)
    run_test("serial-gcc-opt-coverage" + addition, branch, myDB)
    continue

  if is_found ("valgrind") and is_found ("nvcc") and is_found("g++"):
      run_test("serial-gcc-debug-coverage-mkl-quadmath-valgrind-cudamemcheck" + addition, branch, myDB)
  elif is_found ("valgrind") and is_found("g++"):
      run_test("serial-gcc-debug-coverage-mkl-quadmath-valgrind" + addition, branch, myDB)
  elif is_found ("nvcc") and is_found("g++"):
      run_test("serial-gcc-debug-coverage-mkl-quadmath-cudamemcheck" + addition, branch, myDB)

  if is_found("mpic++"):
    if is_found("g++"):
      run_test("mpi-gcc-debug-coverage-quadmath-mkl" + addition, branch, myDB)
      run_test("mpi-gcc-opt-coverage-quadmath-mkl" + addition, branch, myDB)
    if is_found("clang++"):
      run_test("mpi-clang-debug-mkl" + addition, branch, myDB)
      run_test("mpi-clang-opt-mkl" + addition, branch, myDB)
    if is_found("icpc"):
      run_test("mpi-icc-debug-quadmath-mkl" + addition, branch, myDB)
      run_test("mpi-icc-opt-quadmath-mkl" + addition, branch, myDB)

  if is_found("g++"):
    run_test("serial-gcc-debug-coverage-quadmath-mkl" + addition, branch, myDB)
    run_test("serial-gcc-opt-coverage-quadmath-mkl" + addition, branch, myDB)
  if is_found("clang++"):
    run_test("serial-clang-debug-mkl" + addition, branch, myDB)
    run_test("serial-clang-opt-mkl" + addition, branch, myDB)
  if is_found("icpc"):
    run_test("serial-icc-debug-quadmath-mkl" + addition, branch, myDB)
    run_test("serial-icc-opt-quadmath-mkl" + addition, branch, myDB)
