# HowTo Start Using the FEAST Git Repository

# Step 0
# Obligatory reading material:
#   - http://git.or.cz/course/svn.html
#   - [TODO]
#   - Podcasts with HowTos: http://www.gitcasts.com/episodes


# Step 1
# Ensure you are member of the group "feastgit", numeric id is 3001
ssh -p 22122 <own account>@<some host in our network>.mathematik.tu-dortmund.de
groups | grep feastgit
# => output should be non-empty. If empty and you did re-login, ask Christian
#    to add you to the feastgit group
# => [QUESTION] is this necessary if you want to work off your laptop, ie, clone
#    anonymously? In other words, is being a group member a prerequisite
#    for being able to use git anytime everywhere? I guess "yes", because
#    Git opens an ssh tunnel under the hood.


# Step 2
# Ensure git is available
which git
# => should not return an error. Git is currently available on most
#    Linux based hosts at the Faculty of Mathematics, i.e. all Ubuntu 9.10
#    64bit and openSuSE 11.1 32bit hosts.
# => [QUESTION] If git is not available, install it:
#    - On OpenSUSE systems or any system which has a built-in package manager, install [TODO DOM]
#    - On Windows, install [TODO PETER AND MICHAEL]
#    - On any other system, grab the Git installer from here: [TODO]


# [QUESTION] Step 2.5
# Since Git tunnels ssh:
#    - Set up ssh agenting to prevent typing passwords all the time
#    - [TODO] on Windows
#    - [TODO] on Linux


# Step 3
# Checkout FEAST Git repository
mkdir feast.git.working.copy
cd feast.git.working.copy
git clone ssh://<own account>@<some Linux host in our network>.mathematik.tu-dortmund.de:22122/home/user/gitlsiii/feast.git .


# Step 4
# Get and install commit template to avoid having to reword commit messages
# because they are rejected by the master repository on push. Unlike in CVS/SVN,
# the template is not automatically installed, but has to be configure for
# every cloned repository anew.
cp /home/user/gitlsiii/feast.git/commit-template .git
git config commit.template .git/commit-template


# Step 5
# The FEAST Git repository enforces a style guide on commits and commit
# messages. To avoid situations where commits that were successfully made
# locally are rejected when pushed to the server because they violate the style
# guide, it is recommended to set one's local git repository up such that the
# same style guide is enforced there, too. Otherwise, when rejected by the
# server, one would have to reword every commit prior to being able to push it
# (How to do that: git rebase -i HEAD~20, mark all commits to be pushed to be
# reworded, reword them, then push them.)
cd .git/hooks
git init
git pull .. remotes/origin/hooks
cd ../..


# Step 6
# Set your user name and email address. When you use the "-s" option
# (signed-off-by) when committing (which is recommended [TODO: Obligatory by our conventions?]), then your name is
# automatically appended to the commit message.
git config --global user.name "Your Name"
git config --global user.email you@yourdomain.example.com
# The option "--global" means that these settings are used for *all* your
# local git repositories (i.e., it is stored in "~/.gitconfig"). If you
# want to store these settings *per local git repository* then omit the
# --global option. Then the settings are stored in
# "~/<some git project>/.git/config").


# Step 7
# Edit files, commit them locally (see also "Commit Rules" below), e.g.:
#   touch foo.hpp bar.cpp
#   git add foo.hpp bar.cpp
#   git commit -s foo.hpp bar-cpp


# Step 8
# Update and rebase local copy prior to pushing, eventually resolve conflicts
# (short version of the two commands: "git pull")
git fetch -v
git rebase -v origin/master
# [QUESTION] Someone please explain why this doesn't work if I have local edits that conflict with the master.


# Step 9
# Publish them by pushing them to the main repository
git push


# Commit Rules:
# - File format:
#   - All text files have to be in plain ASCII format.
#   - The line endings of ASCII files must be of UNIX-format ('\n').
#   - There must not be any trailing white space and no blank line at the end
#     of the file.
#   - If your editor is not able to automatically meet the two previous
#     conditions, then you have to use another editor to modify the files.
#     Examples:
#     - Windows, notepad++ v5.7 (http://www.notepad-plus-plus.org):
#         select all (CTRL+a)
#         menu "Edit --> EOL conversion --> UNIX-Format"
#         menu "Edit --> Trim Trailing Space"
#     - Unix, vi(m):
#         Use ":%s/\s\+$//" to remove all trailing whitespaces.
#         For details on how to detect and avoid them, refer to
#         http://vim.wikia.com/wiki/Remove_unwanted_spaces
#     - Unix, (x)emacs:
#         ... (missing)
#     - Mac, (missing):
#         ... (missing)
#     - all platforms, jedit v4.3:
#         select all (CTRL+a)
#         menu "Utilities --> Buffer options... --> Line separator --> Unix (\n)"
#         menu "Edit --> Indent --> Remove Trailing Whitespace"
# - Commit message:
#   - The commit messages must not be empty.
#   - Summarise your commit in one leading line with up to 78 characters, using
#     one of the following prefixes:
#
#       BUG:   Bug fix
#       COMP:  Fixed compiler error or warning
#       DOC:   Changed a comment
#       ENH:   Feature Implementation
#       STYLE: Coding style change (indenting, braces, non-bug or feature change)
#
#   - If you want to provide details about your changes (which is HIGHLY
#     RECOMMENDED!), use an empty line as separator and then describe your
#     changes as detailed as appropriate.
#     Golden rule: As long as necessary, as brief as possible!
#     (German: So lang wie noetig, so kurz wie moeglich!)
#   - Example:
#
#       ENH: implemented new feature
#
#       When using bla it was not possible to blub. The now implemented
#       feature allows to blub and bla so that one can bla blub bla blub.
#
#   - Commit must be signed (option "-s"): git commit -s foo.hpp
#   - If any of the above rules is violated, the commit is automatically
#     rejected!


# Useful git commands and tricks:
#
# - Get help
#     git help [command]
# - Add file to local(!) repository:
#     git add foo.hpp
#     git commit
# - Remove file from local(!) repository:
#     git rm foo.hpp
#     git commit
# - Push local commits to the remote repository:
#     git push
#   ("git commit" *plus* "git push" is equivalent to "cvs commit"/"svn commit".)
# - Update local copy prior to pushing, eventually resolve conflicts:
#     git fetch
#     git rebase origin/master
#   Short version (equivalent to "cvs update" or "svn update"):
#     git pull
# - Let git be more verbose: option -v. Examples:
#     git pull -v
# - Let git tell you what *would* happen if you ran a command:
#   option --dry-run or -n (not available for all commands). Examples:
#     git push -n
#     git commit --dry-run
# - See detailed changes that are not yet committed:
#     git diff
#   Equivalent to
#     git diff HEAD
#   (i.e. HEAD is, what you have committed locally via "git commit")
# - See detailed changes, that are not yet committed, compared to the remote
#   master branch:
#     git diff origin/master
# - See detailed changes between your "committed status" (=HEAD) and the remote
#   master branch:
#     git diff HEAD origin/master
# - See changes between your working copy and the remote master branch
#     git diff HEAD origin/master
# - See only the files that contain changes not yet committed:
#     git diff --name-status
# - Show untracked and modified (not committed) files:
#     git status
# - Show commit logs:
#     git log [file]
#
# Customise git:
#
# - Use some diff tool (like tkdiff) instead of standard diff:
#     git difftool --no-prompt [file]
#   If [file] is omitted, the diff tool is invoked for each changed file.
#   Type "git help difftool" for details.
# - Use colorful git:
#     git config --global color.status auto
#     git config --global color.diff auto
#     git config --global color.log auto
# - Set aliases for git. Examples:
#     git config --global alias.remove rm
#        --> type "git remove" instead of "git rm"
#     git config --global alias.changes "diff --name-status"
#        --> type "git changes" to list all files that contain changes not yet
#            committed.
#     git config --global alias.tkdiff "difftool --no-prompt"
#        --> type "git tkdiff [file]" (default diff tool) for invoking tkdiff
#     git config --global alias.commit "commit -s"
#        --> useful if you tend to forget to sign your commits
# - Browse git configuration (aliases, user name, email, ...):
#     git config --list
#
# ... (to be continued)



# Pitfalls:
#
# [QUESTION] Someone please explain why the usual
#    svn up && cvn ci bla.blub
#    does not work in Git (a git pull is not equivalent to an svn up)
#
# [QUESTION] Someone please explain why all of a sudden fresh clones
#    followed by git pull leave some language along the lines of
#    "forced update in branch bla". This has not happened in previous
#    branches.
#
# [QUESTION] Typical "near-paper-deadline" use case:
#    - a colleague hacks away, so do I
#    - with svn, one of us would commit, I would svn up, and I would commit:
#      the intermediate commit would lead to uncompilable code which I would
#      fix with my commit. How do I git that? Would we have to agree on a common
#      branch in advance? How far in advance so that the master doesn't get
#      tainted?
#    - Now assume that edits/hacks have to be spontaneous. How do I post-mortem
#      include a colleague into my paper, assuming that I never branched because
#      I never thought it would have been necessary to do so?
#    - Assuming that I was clever enough to branch off the runs for my paper.
#      I have a ton of uncommitted edits for that (if only tagging of output).
#      A colleague not related with the paper I am working on fixes a major
#      bug. How do I merge that in?
